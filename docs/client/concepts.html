<template name="concepts">

<h1 id="concepts">Concepts</h1>

Мы пишем честное одностраничное веб-приложение на JavaScript.
Пишем все приложение на одном языке (JavaScript) с одним
форматом данных (JSON) и это действительно весело.  Meteor все что вам нужно
когда вы создаете такие веб-приложения.

{{> structure }}
{{> data }}
{{> reactivity }}
{{> livehtml }}
{{> templates }}
{{> packages_concept }}
{{> deploying }}
</template>

<template name="structure">
{{#better_markdown}}

<h2 id="structuringyourapp">Структура приложения</h2>

Стандартное приложение Meteor это смесь JavaScript запущенный внутри браузера
клиента, JavaScript на серверной стороне запущен в контейнере
[Node.js](http://nodejs.org/), как и HTML фрагменты, CSS и статика.
Meteor автоматизирует упаковку и доставку всех этих разных компонентов.
И у вас есть достаточно гибкости для расположение все этих частей внутри
структуры вашего проекта.

Единтсвенная ценность для сервера это JavaScript.  Meteor собирает все JavaScript
файлы, исключая файлы в директориях `client` и `public`и загружает их в Node.js.
В Meteor, ваш серверный код обрабатывает каждый запрос в отдельном потоке,
но не в асинхронной маннере как принято в Node.js.
Мы находим что синхронное исполнение лучше ложится на модель типичного веб-приложения.

На тот же манер обстоят дела с клиентской стороной.  Meteor
собирает все JavaSript файлы в вашем рабочем дереве каталогов
за исключением поддиректорий `server` и `public`.  Он сжимает этот пакет и отдает
каждому новому клиенту.
Вы можете свободно использовать всего один JavaScript файл для всего приложения,
или можете сделать вложенное дерево директории с отдельными файлами,
или придумать что-то еще.

Файлы за пределами директорий `client`, `server` и `tests` будут загружаться
как на клиенте так и на сервере!  Это место для объявления моделей и
других функций используемых как на сервере так и на клиенте.
Meteor предоставляет переменные [`isClient` и `isServer`](#meteor_isclient) так что ваш
код может изменяться в зависимости от места использования (на сервере или клиенте).
(Файлы из директории `tests` не загружаются нигде)

Любой код который вы не хотите отрабатывать на клиенте, например код
содержащий пароли или аутентификационные механизмы, должен храниться
в директории `server`.

CSS файлы лучше держать в одном месте: клиент получит их всех пакетом
из всех CSS в вашем рабочем дереве директорий (за исключением `server`
и `public` поддиректорий).

В режиме разработки, JavaScript и CSS файлы посылаются по отдельности
чтобы облегчить отладку приложения.

HTML файлы в приложении Meteor обрабатываются иначе чем это принято в 
серверных фреймворках.  Meteor сканирует все HTML файлы в вашей
диреткории на предмет трех элементов: `<head>`, `<body>`, и
`<template>`.  Все заголовки и тела собираются в один заголовок и тело
и передаются на клиента при первой загрузке приложения.

Код в секции template, конвертируется в JavaScript
функции, доступные в пространстве имен `Template`.  Это
действительно удобный метод доставки шаблонов клиенту.
Подробности смотри [templates](#templates).

Последнее, сервер Meteor будет раздавать любые файлы из директории
`public`, как например в Rails или Django проекте.  Это место для
изображений, `favicon.ico`, `robots.txt`, и всего остального.

Лучше выстроить приложение так чтобы порядок загрузки файлов не
влиял на его работу, к примеру используя [Meteor.startup](#meteor_startup),
или переместив код в Smart Packages, где вы сможите управлять порядком загрузки пакетов.
Однако иногда переопределить порядок загрузки зависимостей невозможно.
JavaScript и CSS файлы в приложении загружаются сообразно своим правилам:

* Файлы в корневой директории `lib` загружаются первыми.

* Файлы совпадающие с `main.*` загружаются следующими.

* Файлы в поддиректориях загружаются снизу вверх,
  так файлы в наиболее глубоких директориях загружаются первыми
  (сразу после `lib`), а файлы в корневых директориях загружаются последними
  (за исключением `main.*`).

* Внутри директории файлы загружаются в алфавитном порядке.

Это правила, так например  в директории `lib`, для примера, файлы
загрузятся в алфавитном порядке; и если есть файлы `main.js`,
то они загрузятся раньше файлов в поддиректориях.

{{/better_markdown}}
</template>

<template name="data">
{{#better_markdown}}

<h2 id="dataandsecurity">Информация и безопастность</h2>

Meteor дает возможность писать распределенный клиентский код так же
просто как-будто вы напрямую соединины с локальной базой данных.  Это просто,
понятно, безопасно и освобождает вас от реализации RPC, ручного кеширование
данных на клиенте для компенсации задержек, и позволяет аккуратно доставляет все 
сообщения всем клиентам при изменении данных.

В Meteor, клиент и сервер используют единый API базы данных. Код
приложения &mdash; такой как валидаторы и вычисляемые свойства &mdash; могут
быть использованы как на клиенте так и на сервере.  Но код запущенный на сервер
имеет прямой доступ к базе данных, а код на клиенте *нет*.
Это разделение - основы модели безопастности фреймворка.

{{#note}}
По умолчанию, новое приложение включает пакеты `autopublish` и `insecure`,
которые вместе имитируют эффект того что каждый клиент имеет полный доступ
к базе данных на чтение/запись.  Это полезно в качестве мощного инструмента
прототипирования, но обычно неприемлимо для реальных приложения.
При выходе в продакшн просто удалите эти пакеты.
{{/note}}

Каждый клиент Meteor-а включает в себя кеш базы данных.  Для управления
клиентским кешем, сервер *publishes* (публикует) набор JSON документов,
а клиент в свою очеред *subscribes* (подписывается) на эти наборы.
Как только документы в наборе изменяются, сервер патчит кеш каждого клиента 
до актуального состояния.

Каждый набор документов объявлен publish функцией на сервере.
Данная функция запускается каждый раз когда новый клиент подписывается
на набор документов. Данные в наборе документов могут быть откуда угодно,
но в основном публикуются данные из базы.

    // server: публикует все документы комнаты
    Meteor.publish("all-rooms", function () {
      return Rooms.find(); // everything
    );

    // server: публикует все сообщения для конкретной комнаты
    Meteor.publish("messages", function (roomId) {
      return Messages.find({room: roomId});
    });

    // server: публикует список вечеринок которые видит пользователь
    Meteor.publish("parties", function () {
      return Parties.find({$or: [{"public": true},
                                 {invited: this.userId},
                                 {owner: this.userId}]});
    });

Publish функция может отдавать разные результаты каждому клиенту.  
В послденем примере, залогиненный пользователь может видить только 
те документы `Party` которые являются публичными, те которыми пользователь владеет,
или те в которые пользователь приглашен.

Однажды подписавшись, клиент использует свой собственный кэш как локальную
базу данных, это в значительной степени облегчает клиентский код.  
Операции на чтения не тратят время на отсылку и прием запросов с сервера. 
И они ограничены содержимым кэша: запрсо к любому документу вернет в коллекции
вернет только документы которые сервер опубликовал на клиенте.

    // client: start a parties subscription
    Meteor.subscribe("parties");

    // client: return array of Parties this client can read
    return Parties.find().fetch(); // synchronous!

На клиенте можно отключать и включать подписки для контроля
размеров кэша и управления сетевым траффиком.  Когда подписка
отключена, все ее документы удаляются из кэша, но только если 
если нет других активных подписок связанных с этим документом.

Когда на клиенте происходят *changes* (изменения) одного или более документов,
он шлет сообщение на сервер, в свою очеред сервер запрашивает изменения.
После чего осуществляет проверку на соотвествие правил безопастности
которые объявляются как JavaScript функция.
Сервер принимает только те изменния которые не противоречат его политикам.

    // server: запретить запись клиенту в коллекцию Parties
    Parties.allow({
      insert: function (userId, party) {
        return false;
      }
    });

    // client: тут произойдет фейл
    var party = { ... };
    Parties.insert(party);

Если сервер принял изменения, то он применяет их к сначал к базе
, после чего автоматически распространяет изменения на всех клиентов
которые подписаны на этот документ.  В противном случае обновления не происходит,
обновления не применяются к базе данных и другие клиенты соотвественно не получают
никаких обновлений связанных с отброшенным обновлением.

В Meteor использует одну уловку.  Когда клиент отправляет запрос на запись серверу,
он так же обновляет локальный кэш не дожидаясь ответа. 
Это означает, что экран на клиенте обновляется сразу же.
И если сервер принял обновления &mdash; что происходит вбольшинстве
случае, когда клиент работает верно &mdash;, то у клиента изменения вступают 
в силу сразу же и экран обнавлен без какого-либо ответа от сервера.
Но если сервер отверг обновления,  то Meteor обновляет кеш клиента 
актуальными данными из базы данных сервера.

Если сложить все вместе, то все эти техники позволяют компенсировать задержки.
Клиенты всегда имеют свежую копию необходимых им данных, и
не надо тратить время на ожидание времени отправки запроса на сервер и получения ответа,
локальная копия данных на клиенте обновляется мгновенно.

Meteor включает [Meteor Accounts](#accounts_api), систему аутентификации.
Она предоставляет безопастный парольный вход [Secure Remote Password protocol]
(http://en.wikipedia.org/wiki/Secure_Remote_Password_protocol), и
интеграцию с внешними сервисами включая Facebook, GitHub, Google, Twitter,
и Weibo. Meteor Accounts объявляет [`Meteor.users`](#meteor_users) коллекцию
где разработчик может хранить связанную с пользователем информацию.

Meteor так же включает готовые формы дял основных действий таких как вход,
регистрация, смена пароля, и сброс пароля через email. Вы можете добавить [Accounts
UI](#accountsui) в ваше приложение всего одной строкой кода. `accounts-ui` smart
package так же предоставляет визард, который проведет вас через шаги подключения
к внешним сервисам авторизации.

{{#note}}
Настоящий релиз Meteor поддерживает MongoDB, популярную документо-
ориентированную базу данных, документация можно найти
        [MongoDB API](http://www.mongodb.org/display/DOCS/Manual).
В будующем планируется ввести поддержку других баз данных.
{{/note}}

{{/better_markdown}}
</template>

<template name="reactivity">
{{#better_markdown}}

<h2 id="reactivity">Реактивность</h2>

Meteor включает в себя концепцию [reactive
programming](http://en.wikipedia.org/wiki/Reactive_programming). Это означает
что вы можете свой код в простом импиративном стиле, а результат будет пересчитан
автоматически при измении данных с которыми связан ваш код.

    Meteor.autosubscribe(function () {
      Meteor.subscribe("messages", Session.get("currentRoomId"));
    });

Этот пример (взятый из чат-клиента) устанавливает
подписку на данные в переменной сессии `currentRoomId`.
Если даные в `Session.get("currentRoomId")` изменятся по каким-то причинам,
функция автоматически перезапустится, установив новую подписку
заменяя старую.


Этот автоматический пересчет достигается за счет взаимодействия
между `Session` и `Meteor.autosubscribe`.
Методы наподобии `Meteor.autosubscribe` устанавливают "reactive
context" (реактивный контекст) внутри которых отслеживают зависиомсти данных,
и они при необходимости готовы перезапуститься с другим аргументом.  Данные
предоставляемые наподобии функции `Session`, с другой стороны, запоминают
контекст в котором они вызывались и данные которые были запрошены, и они
готовяться к отправке сигнала, о том что произошли изменения.

Этот простой паттерн (reactive context + reactive data source) имеет
широкое применение.  Потому что программист избавлен от необходимости
отписываться/переподписываться и убеждаться что все вызовы происходят в нужное время.  
В общем, Meteor может помочь избежать широкого круга ошибок 
связанных с распростарнением событий и приводящих к ошибкам
логики приложения.

Эти функции Meteor запускают ваш код в реактивном контексте:

* [Templates](#templates)
* [`Meteor.render`](#meteor_render) and [`Meteor.renderList`](#meteor_renderlist)
* [`Meteor.autosubscribe`](#meteor_autosubscribe)
* [`Meteor.autorun`](#meteor_autorun)

И реактивные источники данных которые могут оповещать о измениях:

* [`Session`](#session) variables
* Database queries on [Collections](#find)
* [`Meteor.status`](#meteor_status)
* [`Meteor.user`](#meteor_user)
* [`Meteor.userId`](#meteor_userid)
* [`Meteor.loggingIn`](#meteor_loggingin)

Meteor's
[implementation](https://github.com/meteor/meteor/blob/master/packages/deps/deps.js)
(реализация) коротка и изящна, составляет около 50 строк кода.  Вы можете перхватить
ее самостоятельно для добавления нового реактивного контекста или источника данных,
используя [`Meteor.deps`](#meteor_deps) модуль.

{{/better_markdown}}
</template>

<template name="livehtml">
{{#better_markdown}}

<h2 id="livehtml">:Живой HTML</h2>

HTML шаблоны это одна из центральных тем веб-приложения. С технологией
живого обновления страницы, вы можете рендерить html _reactively_, это 
означает данные обновляется автоматически при обнаружении изменений в них.

Эта технология работает с любым HTML шабланизатором, или даже
с HTML который вы нагенерили вручную из JavaScript. Нпример:

    var fragment = Meteor.render(
      function () {
        var name = Session.get("name") || "Anonymous";
        return "<div>Hello, " + name + "</div>";
      });
    document.body.appendChild(fragment);

    Session.set("name", "Bob"); // строница обновиться автоматически!

[`Meteor.render`](#meteor_render) принимает рендер функцию, которая, 
возвращает HTML в виде строки. Она возвращет автообновляющийся фрагмент
`DocumentFragment`. Когда данные используемые рендер функцией обновляются
то она автоматически перезапускается. [`Meteor.render`](#meteor_render) использует
[reactive contexts](#reactivity) для поиска данных используемых в рендер
функции.

Большуя часть времени вы не будете вызывать эти функции напрямую
&mdash; вы просто используете свой любый шаблонизатор, такой как
Handlebars или Jade. `render` и `renderList` функции интерсны для
разработчиков которые хотят интегрировать свои собственные шаблонизаторы.

Обычно Метеор производит обновления данных когда ваш код не исполняется. 
Таким образом,  вы можете быть уверены в том что DOM
не изменится незаметно для вас(имеется ввиду что сам не добавить элементов в дерево).
Иногда необходимо обратное.
К примеру, если вы только что вставили запись в базу, 
вы захотите запустить принудительное обновление DOM тогда для
поиска и создания новых элементов вы можете использовать библиотеки на
подобии jQuery. Так вы можете вызвать [`Meteor.flush`](#meteor_flush)
дял того чтобы обновить DOM немедлено.

Когда авто-обновляющиеся DOM исчезают с экрана, они автоматически удаляются &mdash; 
их колбеки отключаются, любые полсаные в базу данных запросы останавливаются, 
и они перестают обновляться. Поэтому вам никогда не придется беспокоится о
[zombie templates](http://lostechies.com/derickbailey/2011/09/15/zombies-run-managing-page-transitions-in-backbone-apps/)
которые порождает вручную написания логика обновлений. Для защиты своих элементов от уничтожения,
просто убедитесь что они на экране до того как ваш код вернется в event loop,
или до любых вызовов [`Meteor.flush`](#meteor_flush).

Другой интересной проблемой в веб-приложении является сохрание
элемента. Представим что пользователь пишет текст в  `<input>`
элемент, и когда участок страницы который включает этот элемент
перерисовывается. Пользователь например может сместить фокус в приложении
и частиточно введеный текст пропадет в перерисованном `<input>`.

Еще одна проблема которую Метеор решает для вас. Вы можете определить элементы
для сохранения когда шаблоны пересоздаются с
[`preserve`](#template_preserve) дерективой в шаблоне.

{{/better_markdown}}
</template>

<template name="templates">
{{#better_markdown}}

<h2 id="templates">Шаблоны</h2>

Метеор упрощает использование вашего любимого шаблонного языка,
таких как Handlebars или Jade, с технологие обновление шаблонов налету
Просто пишите свои шаблоны как обычно, а Метеор
позаботиться о их обновлении.

Для использования это возможности, создайте файл с расширением `.html`
В файле, создайте `<template>` тег и задайте ему аттрибут `name` . 
Поместите содержимое шаблона внутри тега. Метеор
скомпелирует шаблон, передаст его на клиента, и сделает
его досутпным в виде функции в глобальном объекте `Template` .

{{#note}}
Сегодня, в Метеоре доступен только один шаблонизатор Handlebars.
Дайте нам знать какие шаблонизаторы вы бы хотели использовать с 
Метеором. Так же смотрите [Handlebars
документацию](http://www.handlebarsjs.com/) and [Meteor Handlebars
расширения](https://github.com/meteor/meteor/wiki/Handlebars).
{{/note}}

Шаблон с именем `hello` рендерится функцией `Template.hello`,
передавая любые данные в шаблон:

    <!-- in myapp.html -->
    <template name="hello">
      <div class="greeting">Hello there, {{dstache}}first}} {{dstache}}last}}!</div>
    </{{! }}template>

    // in the JavaScript console
    > Template.hello({first: "Alyssa", last: "Hacker"});
     => "<div class="greeting">Hello there, Alyssa Hacker!</div>"

Это вернет строку. Для использования шаблона с [`Live
HTML`](#livehtml), и получения DOM элементов которые обновляются
автоматически, исполуйте [`Meteor.render`](#meteor_render):

    Meteor.render(function () {
      return Template.hello({first: "Alyssa", last: "Hacker"});
    })
      => автоматическое обновление DOM элементов

Простейший путь пердать данные в шаблон это определние функции хелпера на JavaScript.
Просто добавьте функцию хелпер прямо в 
`Template.[template name]` объект. Как например в этом шаблоне:

    <template name="players">
      {{dstache}}#each topScorers}}
        <div>{{dstache}}name}}</div>
      {{dstache}}/each}}
    </{{! }}template>

вместо передачи `topScorers` как данных когда мы вызываем
шаблонную функцию, мы можем определить функцию в `Template.players`:

    Template.players.topScorers = function () {
      return Users.find({score: {$gt: 100}}, {sort: {score: -1}});
    };

В таком случае, данные приходят из запроса в базу. Когда
курсор базы доходит до `#each`, он соединит и будет эффективно
добавлять иили пересещать DOM узлы как новые результаты введеного
запроса.

Хелперы могут принимать аргументы, и они принимают актуальные данные шаблона
в `this`:

    // in a JavaScript file
    Template.players.leagueIs = function (league) {
      return this.league === league;
    };

    <!-- in a HTML file -->
    <template name="players">
      {{dstache}}#each topScorers}}
        {{dstache}}#if leagueIs "junior"}}
          <div>Junior: {{dstache}}name}}</div>
        {{dstache}}/if}}
        {{dstache}}#if leagueIs "senior"}}
          <div>Senior: {{dstache}}name}}</div>
        {{dstache}}/if}}
      {{dstache}}/each}}
    </{{! }}template>

{{#note}}
Handlebars заметка: `{{dstache}}#if leagueIs "junior"}}`
это расширение Метеора которое допускает вкладывать блоки
хелперов в дург друга. (Оба `if` и `leagueIs`
хелперы, обычный Handlebars не будет вызывать
`leagueIs` здесь.)
{{/note}}

Хелперы так же можно использовать для передачи констант.

    // Works fine with {{dstache}}#each sections}}
    Template.report.sections = ["Situation", "Complication", "Resolution"];

Наконец, вы можете использовать `events` декларации в шаблоных функциях для установки
таблицы обработчиков событий. Формат задокументирован в [Event
Maps](#eventmaps). `this` аргумент для обработчика события будет
контекстом элемента запустившего событие.

    <!-- myapp.html -->
    <template name="scores">
      {{dstache}}#each player}}
        {{dstache}}> playerScore}}
      {{dstache}}/each}}
    </{{! }}template>

    <template name="playerScore">
      <div>{{dstache}}name}}: {{dstache}}score}}
        <span class="givePoints">Give points</span>
      </div>
    </{{! }}template>

    <!-- myapp.js -->
    Template.playerScore.events({
      'click .givePoints': function () {
        Users.update({_id: this._id}, {$inc: {score: 2}});
      }
    });

Сложим все вместе, пример как вы можете добавить
произвольные данные в ваши шаблоны, и получить автообновления
при любых изменениях данных. Смотрите [Live HTML](#livehtml).

    <!-- in myapp.html -->
    <template name="forecast">
      <div>It'll be {{dstache}}prediction}} tonight</div>
    </{{! }}template>

    <!-- in myapp.js -->
    // JavaScript: reactive helper function
    Template.forecast.prediction = function () {
      return Session.get("weather");
    };

    <!-- in the console -->
    > Session.set("weather", "cloudy");
    > document.body.appendChild(Meteor.render(Template.forecast));
    In DOM:  <div>It'll be cloudy tonight</div>

    > Session.set("weather", "cool and dry");
    In DOM:  <div>It'll be cool and dry tonight</div>

{{/better_markdown}}
</template>

<template name="packages_concept">
{{#better_markdown}}

  <h2 id="smartpackages">Smart packages</h2>

Meteor has an unusually powerful package system. All of the
functionality you've read about so far is implemented as standard
Meteor packages.

Meteor packages are intelligent: the packages are themselves
JavaScript programs. They can inject code into the client or the
server, or hook new functions into the bundler, so they can extend the
Meteor environment in arbitrary ways. Some examples of packages are:

* The [coffeescript](#coffeescript) package extends the
  bundler, automatically compiling any `.coffee` files in
  your tree.  Once added, you can write your application in CoffeeScript
  instead of JavaScript.

* The [jQuery](#jquery) and [Backbone](#backbone) packages are examples of using
  Meteor to prepackage client JavaScript libraries. You could get
  the same result by copying the JavaScript files into your tree, but
  it's faster to add a package.

* The [underscore](#underscore) package extends both the
  client and server environments.  Many of the core Meteor features,
  including Minimongo, the Session object, and reactive Handlebars
  templates, are implemented as internal packages automatically
  included with every Meteor application.

You can see a list of available packages
with [`meteor list`](#meteorlist), add packages to your project
with [`meteor add`](#meteoradd), and remove them
with [`meteor remove`](#meteorremove).

See the [Package List](#packages) section for a description
of the existing packages.

{{#warning}}
The package API is rapidly changing and isn't documented, so you can't
make your own packages just yet. Coming soon.
{{/warning}}

{{/better_markdown}}
</template>





<template name="deploying">
{{#better_markdown}}

<h2 id="deploying">Deploying</h2>

Meteor is a full application server.  We include everything you need
to deploy your application on the internet: you just provide the JavaScript,
HTML, and CSS.

<h3 class="nosection">Running on Meteor's infrastructure</h3>

The easiest way to deploy your application is to use `meteor
deploy`.  We provide it because it's what, personally, we've always
wanted: an easy way to take an app idea, flesh it out over a weekend,
and put it out there for the world to use, with nothing getting in the
way of creativity.

    $ meteor deploy myapp.meteor.com

Your application is now available at myapp.meteor.com.  If
this is the first time deploying to this hostname, Meteor creates a
fresh empty database for your application.  If you want to deploy an
update, Meteor will preserve the existing data and just refresh the
code.

You can also deploy to your own domain.  Just set up the hostname you
want to use as a CNAME to `origin.meteor.com`,
then deploy to that name.

    $ meteor deploy www.myapp.com

We provide this as a free service so you can try Meteor.  It is also
helpful for quickly putting up internal betas, demos, and so on.

<h3 class="nosection">Running on your own infrastructure</h3>

You can run also your application on your own infrastructure, or any
other hosting provider like Heroku.

To get started, run

    $ meteor bundle myapp.tgz

This command will generate a fully-contained Node.js application in
the form of a tarball.  To run this application, you need to provide
Node.js 0.8 and a MongoDB server.  You can then run the application by
invoking node, specifying the HTTP port for the application to listen
on, and the MongoDB endpoint.  If you don't already have a MongoDB
server, we can recommend our friends at [MongoHQ](http://mongohq.com).

    $ PORT=3000 MONGO_URL=mongodb://localhost:27017/myapp node bundle/main.js

Other packages may require other environment variables (for example, the `email`
package requires a `MAIL_URL` environment variable).

{{#warning}}
For now, bundles will only run on the platform that the bundle was
created on.  To run on a different platform, you'll need to rebuild
the native packages included in the bundle.  To do that, make sure you
have `npm` available, and run the following:

    $ cd bundle/server/node_modules
    $ rm -r fibers
    $ npm install fibers@0.6.9
{{/warning}}

{{/better_markdown}}
</template>

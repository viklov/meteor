<template name="concepts">

<h1 id="concepts">Concepts</h1>

Мы пишем честное одностраничное веб-приложение на JavaScript.
Пишем все приложение на одном языке (JavaScript) с одним
форматом данных (JSON) и это действительно весело.  Meteor все что вам нужно
когда вы создаете такие веб-приложения.

{{> structure }}
{{> data }}
{{> reactivity }}
{{> livehtml }}
{{> templates }}
{{> packages_concept }}
{{> deploying }}
</template>

<template name="structure">
{{#better_markdown}}

<h2 id="structuringyourapp">Структура приложения</h2>

Стандартное приложение Meteor это смесь JavaScript запущенный внутри браузера
клиента, JavaScript на серверной стороне запущен в контейнере
[Node.js](http://nodejs.org/), как и HTML фрагменты, CSS и статика.
Meteor автоматизирует упаковку и доставку всех этих разных компонентов.
И у вас есть достаточно гибкости для расположение все этих частей внутри
структуры вашего проекта.

Единтсвенная ценность для сервера это JavaScript.  Meteor собирает все JavaScript
файлы, исключая файлы в директориях `client` и `public`и загружает их в Node.js.
В Meteor, ваш серверный код обрабатывает каждый запрос в отдельном потоке,
но не в асинхронной маннере как принято в Node.js.
Мы находим что синхронное исполнение лучше ложится на модель типичного веб-приложения.

На тот же манер обстоят дела с клиентской стороной.  Meteor
собирает все JavaSript файлы в вашем рабочем дереве каталогов
за исключением поддиректорий `server` и `public`.  Он сжимает этот пакет и отдает
каждому новому клиенту.
Вы можете свободно использовать всего один JavaScript файл для всего приложения,
или можете сделать вложенное дерево директории с отдельными файлами,
или придумать что-то еще.

Файлы за пределами директорий `client`, `server` и `tests` будут загружаться
как на клиенте так и на сервере!  Это место для объявления моделей и
других функций используемых как на сервере так и на клиенте.
Meteor предоставляет переменные [`isClient` и `isServer`](#meteor_isclient) так что ваш
код может изменяться в зависимости от места использования (на сервере или клиенте).
(Файлы из директории `tests` не загружаются нигде)

Любой код который вы не хотите отрабатывать на клиенте, например код
содержащий пароли или аутентификационные механизмы, должен храниться
в директории `server`.

CSS файлы лучше держать в одном месте: клиент получит их всех пакетом
из всех CSS в вашем рабочем дереве директорий (за исключением `server`
и `public` поддиректорий).

В режиме разработки, JavaScript и CSS файлы посылаются по отдельности
чтобы облегчить отладку приложения.

HTML файлы в приложении Meteor обрабатываются иначе чем это принято в 
серверных фреймворках.  Meteor сканирует все HTML файлы в вашей
диреткории на предмет трех элементов: `<head>`, `<body>`, и
`<template>`.  Все заголовки и тела собираются в один заголовок и тело
и передаются на клиента при первой загрузке приложения.

Код в секции template, конвертируется в JavaScript
функции, доступные в пространстве имен `Template`.  Это
действительно удобный метод доставки шаблонов клиенту.
Подробности смотри [templates](#templates).

Последнее, сервер Meteor будет раздавать любые файлы из директории
`public`, как например в Rails или Django проекте.  Это место для
изображений, `favicon.ico`, `robots.txt`, и всего остального.

Лучше выстроить приложение так чтобы порядок загрузки файлов не
влиял на его работу, к примеру используя [Meteor.startup](#meteor_startup),
или переместив код в Smart Packages, где вы сможите управлять порядком загрузки пакетов.
Однако иногда переопределить порядок загрузки зависимостей невозможно.
JavaScript и CSS файлы в приложении загружаются сообразно своим правилам:

* Файлы в корневой директории `lib` загружаются первыми.

* Файлы совпадающие с `main.*` загружаются следующими.

* Файлы в поддиректориях загружаются снизу вверх,
  так файлы в наиболее глубоких директориях загружаются первыми
  (сразу после `lib`), а файлы в корневых директориях загружаются последними
  (за исключением `main.*`).

* Внутри директории файлы загружаются в алфавитном порядке.

Это правила, так например  в директории `lib`, для примера, файлы
загрузятся в алфавитном порядке; и если есть файлы `main.js`,
то они загрузятся раньше файлов в поддиректориях.

{{/better_markdown}}
</template>

<template name="data">
{{#better_markdown}}

<h2 id="dataandsecurity">Информация и безопастность</h2>

Meteor дает возможность писать распределенный клиентский код так же
просто как-будто вы напрямую соединины с локальной базой данных.  Это просто,
понятно, безопасно и освобождает вас от реализации RPC, ручного кеширование
данных на клиенте для компенсации задержек, и позволяет аккуратно доставляет все 
сообщения всем клиентам при изменении данных.

В Meteor, клиент и сервер используют единый API базы данных. Код
приложения &mdash; такой как валидаторы и вычисляемые свойства &mdash; могут
быть использованы как на клиенте так и на сервере.  Но код запущенный на сервер
имеет прямой доступ к базе данных, а код на клиенте *нет*.
Это разделение - основы модели безопастности фреймворка.

{{#note}}
По умолчанию, новое приложение включает пакеты `autopublish` и `insecure`,
которые вместе имитируют эффект того что каждый клиент имеет полный доступ
к базе данных на чтение/запись.  Это полезно в качестве мощного инструмента
прототипирования, но обычно неприемлимо для реальных приложения.
При выходе в продакшн просто удалите эти пакеты.
{{/note}}

Каждый клиент Meteor-а включает в себя кеш базы данных.  Для управления
клиентским кешем, сервер *publishes* (публикует) набор JSON документов,
а клиент в свою очеред *subscribes* (подписывается) на эти наборы.
Как только документы в наборе изменяются, сервер патчит кеш каждого клиента 
до актуального состояния.

Каждый набор документов объявлен publish функцией на сервере.
Данная функция запускается каждый раз когда новый клиент подписывается
на набор документов. Данные в наборе документов могут быть откуда угодно,
но в основном публикуются данные из базы.

    // server: публикует все документы комнаты
    Meteor.publish("all-rooms", function () {
      return Rooms.find(); // everything
    );

    // server: публикует все сообщения для конкретной комнаты
    Meteor.publish("messages", function (roomId) {
      return Messages.find({room: roomId});
    });

    // server: публикует список вечеринок которые видит пользователь
    Meteor.publish("parties", function () {
      return Parties.find({$or: [{"public": true},
                                 {invited: this.userId},
                                 {owner: this.userId}]});
    });

Publish функция может отдавать разные результаты каждому клиенту.  
В послденем примере, залогиненный пользователь может видить только 
те документы `Party` которые являются публичными, те которыми пользователь владеет,
или те в которые пользователь приглашен.

Однажды подписавшись, клиент использует свой собственный кэш как локальную
базу данных, это в значительной степени облегчает клиентский код.  
Операции на чтения не тратят время на отсылку и прием запросов с сервера. 
И они ограничены содержимым кэша: запрсо к любому документу вернет в коллекции
вернет только документы которые сервер опубликовал на клиенте.

    // client: start a parties subscription
    Meteor.subscribe("parties");

    // client: return array of Parties this client can read
    return Parties.find().fetch(); // synchronous!

На клиенте можно отключать и включать подписки для контроля
размеров кэша и управления сетевым траффиком.  Когда подписка
отключена, все ее документы удаляются из кэша, но только если 
если нет других активных подписок связанных с этим документом.

Когда на клиенте происходят *changes* (изменения) одного или более документов,
он шлет сообщение на сервер, в свою очеред сервер запрашивает изменения.
После чего осуществляет проверку на соотвествие правил безопастности
которые объявляются как JavaScript функция.
Сервер принимает только те изменния которые не противоречат его политикам.

    // server: запретить запись клиенту в коллекцию Parties
    Parties.allow({
      insert: function (userId, party) {
        return false;
      }
    });

    // client: тут произойдет фейл
    var party = { ... };
    Parties.insert(party);

Если сервер принял изменения, то он применяет их к сначал к базе
, после чего автоматически распространяет изменения на всех клиентов
которые подписаны на этот документ.  В противном случае обновления не происходит,
обновления не применяются к базе данных и другие клиенты соотвественно не получают
никаких обновлений связанных с отброшенным обновлением.

В Meteor использует одну уловку.  Когда клиент отправляет запрос на запись серверу,
он так же обновляет локальный кэш не дожидаясь ответа. 
Это означает, что экран на клиенте обновляется сразу же.
И если сервер принял обновления &mdash; что происходит вбольшинстве
случае, когда клиент работает верно &mdash;, то у клиента изменения вступают 
в силу сразу же и экран обнавлен без какого-либо ответа от сервера.
Но если сервер отверг обновления,  то Meteor обновляет кеш клиента 
актуальными данными из базы данных сервера.

Если сложить все вместе, то все эти техники позволяют компенсировать задержки.
Клиенты всегда имеют свежую копию необходимых им данных, и
не надо тратить время на ожидание времени отправки запроса на сервер и получения ответа,
локальная копия данных на клиенте обновляется мгновенно.

Meteor включает [Meteor Accounts](#accounts_api), систему аутентификации.
Она предоставляет безопастный парольный вход [Secure Remote Password protocol]
(http://en.wikipedia.org/wiki/Secure_Remote_Password_protocol), и
интеграцию с внешними сервисами включая Facebook, GitHub, Google, Twitter,
и Weibo. Meteor Accounts объявляет [`Meteor.users`](#meteor_users) коллекцию
где разработчик может хранить связанную с пользователем информацию.

Meteor так же включает готовые формы дял основных действий таких как вход,
регистрация, смена пароля, и сброс пароля через email. Вы можете добавить [Accounts
UI](#accountsui) в ваше приложение всего одной строкой кода. `accounts-ui` smart
package так же предоставляет визард, который проведет вас через шаги подключения
к внешним сервисам авторизации.

{{#note}}
Настоящий релиз Meteor поддерживает MongoDB, популярную документо-
ориентированную базу данных, документация можно найти
        [MongoDB API](http://www.mongodb.org/display/DOCS/Manual).
В будующем планируется ввести поддержку других баз данных.
{{/note}}

{{/better_markdown}}
</template>

<template name="reactivity">
{{#better_markdown}}

<h2 id="reactivity">Reactivity</h2>

Meteor embraces the concept of [reactive
programming](http://en.wikipedia.org/wiki/Reactive_programming). This means that
you can write your code in a simple imperative style, and the result will be
automatically recalculated whenever data changes that your code depends on.

    Meteor.autosubscribe(function () {
      Meteor.subscribe("messages", Session.get("currentRoomId"));
    });

This example (taken from a chat room client) sets up a data
subscription based on the session variable `currentRoomId`.
If the value of `Session.get("currentRoomId")` changes for any reason, the
function will be automatically re-run, setting up a new subscription that
replaces the old one.

This automatic recomputation is achieved by a cooperation
between `Session` and `Meteor.autosubscribe`.
Methods like `Meteor.autosubscribe` establish a "reactive
context" inside of which data dependencies are tracked, and they are
prepared to re-run their function argument as necessary.  Data
providers like `Session`, on the other hand, make note of
the context they are called from and what data was requested, and they
are prepared to send an invalidation signal when the data changes.

This simple pattern (reactive context + reactive data source) has wide
applicability.  Above, the programmer is saved from writing
unsubscribe/resubscribe calls and making sure they are called at the
right time.  In general, Meteor can eliminate whole classes of data
propagation code which would otherwise clog up your application with
error-prone logic.

These Meteor functions run your code in a reactive context:

* [Templates](#templates)
* [`Meteor.render`](#meteor_render) and [`Meteor.renderList`](#meteor_renderlist)
* [`Meteor.autosubscribe`](#meteor_autosubscribe)
* [`Meteor.autorun`](#meteor_autorun)

And the reactive data sources that can trigger changes are:

* [`Session`](#session) variables
* Database queries on [Collections](#find)
* [`Meteor.status`](#meteor_status)
* [`Meteor.user`](#meteor_user)
* [`Meteor.userId`](#meteor_userid)
* [`Meteor.loggingIn`](#meteor_loggingin)

Meteor's
[implementation](https://github.com/meteor/meteor/blob/master/packages/deps/deps.js)
of reactivity is short and sweet, about 50 lines of code.  You can hook into it
yourself to add new reactive contexts or data sources, using the
[`Meteor.deps`](#meteor_deps) module.

{{/better_markdown}}
</template>

<template name="livehtml">
{{#better_markdown}}

<h2 id="livehtml">Live HTML</h2>

HTML templating is central to web applications. With Meteor's live
page update technology, you can render your HTML _reactively_, meaning
that it will update automatically to track changes in the data used to
generate it.

This optional feature works with any HTML templating library, or even
with HTML you generate manually from Javascript. Here's an example:

    var fragment = Meteor.render(
      function () {
        var name = Session.get("name") || "Anonymous";
        return "<div>Hello, " + name + "</div>";
      });
    document.body.appendChild(fragment);

    Session.set("name", "Bob"); // page updates automatically!

[`Meteor.render`](#meteor_render) takes a rendering function, that is, a
function that returns some HTML as a string. It returns an auto-updating
`DocumentFragment`. When there is a change to data used by the rendering
function, it is re-run. The DOM nodes in the `DocumentFragment` then
update themselves in-place, no matter where they were inserted on the
page. It's completely automatic. [`Meteor.render`](#meteor_render) uses
[reactive contexts](#reactivity) to discover what data is used by the
rendering function.

Most of the time, though, you won't call these functions directly
&mdash; you'll just use your favorite templating package, such as
Handlebars or Jade. The `render` and `renderList` functions are intended
for people that are implementing new templating systems.

Meteor normally batches up any needed updates and executes them only
when your code isn't running. That way, you can be sure that the DOM
won't change out from underneath you. Sometimes you want the opposite
behavior. For example, if you've just inserted a record in the
database, you might want to force the DOM to update so you can find
the new elements using a library like jQuery. In that case, call
[`Meteor.flush`](#meteor_flush) to bring the DOM up to date
immediately.

When live-updating DOM elements are taken off the screen, they are automatically
cleaned up &mdash; their callbacks are torn down, any associated database
queries are stopped, and they stop updating. For this reason, you never have to
worry about the [zombie
templates](http://lostechies.com/derickbailey/2011/09/15/zombies-run-managing-page-transitions-in-backbone-apps/)
that plague hand-written update logic. To protect your elements from cleanup,
just make sure that they on-screen before your code returns to the event loop,
or before any call you make to [`Meteor.flush`](#meteor_flush).

Another thorny problem in hand-written applications is element
preservation. Suppose the user is typing text into an `<input>`
element, and then the area of the page that includes that element is
redrawn. The user could be in for a bumpy ride, as the focus, the
cursor position, the partially entered text, and the accented
character input state will be lost when the `<input>` is recreated.

This is another problem that Meteor solves for you. You can specify
elements to preserve when templates are re-rendered with the
[`preserve`](#template_preserve) directive on the template. Meteor will
preserve these elements even when their enclosing template is
rerendered, but will still update their children and copy over any
attribute changes.

{{/better_markdown}}
</template>

<template name="templates">
{{#better_markdown}}

<h2 id="templates">Templates</h2>

Meteor makes it easy to use your favorite HTML templating language,
such as Handlebars or Jade, along with Meteor's live page update
technology. Just write your template as you normally would, and Meteor
will take care of making it update in realtime.

To use this feature, create a file in your project with the `.html`
extension. In the file, make a `<template>` tag and give it a
`name` attribute. Put the template contents inside the tag. Meteor
will precompile the template, ship it down to the client, and make it
available as a function on the global `Template` object.

{{#note}}
Today, the only templating system that has been packaged for Meteor is
Handlebars. Let us know what templating systems you'd like to use with
Meteor. Meanwhile, see the [Handlebars
documentation](http://www.handlebarsjs.com/) and [Meteor Handlebars
extensions](https://github.com/meteor/meteor/wiki/Handlebars).
{{/note}}

A template with a `name` of `hello` is rendered by calling the
function `Template.hello`, passing any data for the template:

    <!-- in myapp.html -->
    <template name="hello">
      <div class="greeting">Hello there, {{dstache}}first}} {{dstache}}last}}!</div>
    </{{! }}template>

    // in the JavaScript console
    > Template.hello({first: "Alyssa", last: "Hacker"});
     => "<div class="greeting">Hello there, Alyssa Hacker!</div>"

This returns a string. To use the template along with the [`Live
HTML`](#livehtml) system, and get DOM elements that update
automatically in place, use [`Meteor.render`](#meteor_render):

    Meteor.render(function () {
      return Template.hello({first: "Alyssa", last: "Hacker"});
    })
      => automatically updating DOM elements

The easiest way to get data into templates is by defining helper
functions in JavaScript. Just add the helper functions directly on the
`Template.[template name]` object. For example, in this template:

    <template name="players">
      {{dstache}}#each topScorers}}
        <div>{{dstache}}name}}</div>
      {{dstache}}/each}}
    </{{! }}template>

instead of passing in `topScorers` as data when we call the
template function, we could define a function on `Template.players`:

    Template.players.topScorers = function () {
      return Users.find({score: {$gt: 100}}, {sort: {score: -1}});
    };

In this case, the data is coming from a database query. When the
database cursor is passed to `#each`, it will wire up all of the
machinery to efficiently add and move DOM nodes as new results enter
the query.

Helpers can take arguments, and they receive the current template data
in `this`:

    // in a JavaScript file
    Template.players.leagueIs = function (league) {
      return this.league === league;
    };

    <!-- in a HTML file -->
    <template name="players">
      {{dstache}}#each topScorers}}
        {{dstache}}#if leagueIs "junior"}}
          <div>Junior: {{dstache}}name}}</div>
        {{dstache}}/if}}
        {{dstache}}#if leagueIs "senior"}}
          <div>Senior: {{dstache}}name}}</div>
        {{dstache}}/if}}
      {{dstache}}/each}}
    </{{! }}template>

{{#note}}
Handlebars note: `{{dstache}}#if leagueIs "junior"}}` is
allowed because of a Meteor extension that allows nesting a helper
in a block helper. (Both `if` and `leagueIs` are
technically helpers, and stock Handlebars would not invoke
`leagueIs` here.)
{{/note}}

Helpers can also be used to pass in constant data.

    // Works fine with {{dstache}}#each sections}}
    Template.report.sections = ["Situation", "Complication", "Resolution"];

Finally, you can use an `events` declaration on a template function to set up a
table of event handlers. The format is documented at [Event
Maps](#eventmaps). The `this` argument to the event handler will be
the data context of the element that triggered the event.

    <!-- myapp.html -->
    <template name="scores">
      {{dstache}}#each player}}
        {{dstache}}> playerScore}}
      {{dstache}}/each}}
    </{{! }}template>

    <template name="playerScore">
      <div>{{dstache}}name}}: {{dstache}}score}}
        <span class="givePoints">Give points</span>
      </div>
    </{{! }}template>

    <!-- myapp.js -->
    Template.playerScore.events({
      'click .givePoints': function () {
        Users.update({_id: this._id}, {$inc: {score: 2}});
      }
    });

Putting it all together, here's an example of how you can inject
arbitrary data into your templates, and have them update automatically
whenever that data changes. See [Live HTML](#livehtml) for further
discussion.

    <!-- in myapp.html -->
    <template name="forecast">
      <div>It'll be {{dstache}}prediction}} tonight</div>
    </{{! }}template>

    <!-- in myapp.js -->
    // JavaScript: reactive helper function
    Template.forecast.prediction = function () {
      return Session.get("weather");
    };

    <!-- in the console -->
    > Session.set("weather", "cloudy");
    > document.body.appendChild(Meteor.render(Template.forecast));
    In DOM:  <div>It'll be cloudy tonight</div>

    > Session.set("weather", "cool and dry");
    In DOM:  <div>It'll be cool and dry tonight</div>

{{/better_markdown}}
</template>

<template name="packages_concept">
{{#better_markdown}}

  <h2 id="smartpackages">Smart packages</h2>

Meteor has an unusually powerful package system. All of the
functionality you've read about so far is implemented as standard
Meteor packages.

Meteor packages are intelligent: the packages are themselves
JavaScript programs. They can inject code into the client or the
server, or hook new functions into the bundler, so they can extend the
Meteor environment in arbitrary ways. Some examples of packages are:

* The [coffeescript](#coffeescript) package extends the
  bundler, automatically compiling any `.coffee` files in
  your tree.  Once added, you can write your application in CoffeeScript
  instead of JavaScript.

* The [jQuery](#jquery) and [Backbone](#backbone) packages are examples of using
  Meteor to prepackage client JavaScript libraries. You could get
  the same result by copying the JavaScript files into your tree, but
  it's faster to add a package.

* The [underscore](#underscore) package extends both the
  client and server environments.  Many of the core Meteor features,
  including Minimongo, the Session object, and reactive Handlebars
  templates, are implemented as internal packages automatically
  included with every Meteor application.

You can see a list of available packages
with [`meteor list`](#meteorlist), add packages to your project
with [`meteor add`](#meteoradd), and remove them
with [`meteor remove`](#meteorremove).

See the [Package List](#packages) section for a description
of the existing packages.

{{#warning}}
The package API is rapidly changing and isn't documented, so you can't
make your own packages just yet. Coming soon.
{{/warning}}

{{/better_markdown}}
</template>





<template name="deploying">
{{#better_markdown}}

<h2 id="deploying">Deploying</h2>

Meteor is a full application server.  We include everything you need
to deploy your application on the internet: you just provide the JavaScript,
HTML, and CSS.

<h3 class="nosection">Running on Meteor's infrastructure</h3>

The easiest way to deploy your application is to use `meteor
deploy`.  We provide it because it's what, personally, we've always
wanted: an easy way to take an app idea, flesh it out over a weekend,
and put it out there for the world to use, with nothing getting in the
way of creativity.

    $ meteor deploy myapp.meteor.com

Your application is now available at myapp.meteor.com.  If
this is the first time deploying to this hostname, Meteor creates a
fresh empty database for your application.  If you want to deploy an
update, Meteor will preserve the existing data and just refresh the
code.

You can also deploy to your own domain.  Just set up the hostname you
want to use as a CNAME to `origin.meteor.com`,
then deploy to that name.

    $ meteor deploy www.myapp.com

We provide this as a free service so you can try Meteor.  It is also
helpful for quickly putting up internal betas, demos, and so on.

<h3 class="nosection">Running on your own infrastructure</h3>

You can run also your application on your own infrastructure, or any
other hosting provider like Heroku.

To get started, run

    $ meteor bundle myapp.tgz

This command will generate a fully-contained Node.js application in
the form of a tarball.  To run this application, you need to provide
Node.js 0.8 and a MongoDB server.  You can then run the application by
invoking node, specifying the HTTP port for the application to listen
on, and the MongoDB endpoint.  If you don't already have a MongoDB
server, we can recommend our friends at [MongoHQ](http://mongohq.com).

    $ PORT=3000 MONGO_URL=mongodb://localhost:27017/myapp node bundle/main.js

Other packages may require other environment variables (for example, the `email`
package requires a `MAIL_URL` environment variable).

{{#warning}}
For now, bundles will only run on the platform that the bundle was
created on.  To run on a different platform, you'll need to rebuild
the native packages included in the bundle.  To do that, make sure you
have `npm` available, and run the following:

    $ cd bundle/server/node_modules
    $ rm -r fibers
    $ npm install fibers@0.6.9
{{/warning}}

{{/better_markdown}}
</template>

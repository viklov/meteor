<template name="concepts">

<h1 id="concepts">Concepts</h1>

Мы пишем честное одностраничное веб-приложение на JavaScript.
Пишем все приложение на одном языке (JavaScript) с одним
форматом данных (JSON) и это действительно весело.  Meteor - все что вам нужно,
когда вы создаете такие веб-приложения.

{{> structure }}
{{> data }}
{{> reactivity }}
{{> livehtml }}
{{> templates }}
{{> packages_concept }}
{{> deploying }}
</template>

<template name="structure">
{{#better_markdown}}

<h2 id="structuringyourapp">Структура приложения</h2>

Стандартное приложение Meteor - это смесь JavaScript запущенного внутри браузера
клиента , JavaScript на серверной стороне запущенного в контейнере
[Node.js](http://nodejs.org/),  HTML фрагментов, CSS и статики.
Meteor автоматизирует упаковку и доставку всех этих разных компонентов,
и у вас есть достаточно гибкости для расположение все этих частей внутри
структуры вашего проекта.

Единтсвенная ценность для сервера - это JavaScript.  Meteor собирает все JavaScript
файлы, исключая файлы в директориях `client` и `public`, и загружает их в Node.js.
В Meteor ваш серверный код обрабатывает каждый запрос в отдельном потоке,
но не в асинхронной маннере, как принято в Node.js.
Мы находим, что синхронное исполнение лучше ложится на модель типичного веб-приложения.

На тот же манер обстоят дела с клиентской стороной.  Meteor
собирает все JavaSript файлы в вашем рабочем дереве каталогов
(за исключением поддиректорий `server` и `public`).  Он сжимает этот пакет и отдает
каждому новому клиенту.
Вы можете свободно использовать всего один JavaScript файл для всего приложения,
или можете сделать вложенное дерево директории с отдельными файлами,
или придумать что-то еще.

Файлы за пределами директорий `client`, `server` и `tests` будут загружаться
как на клиенте, так и на сервере!  Это место для объявления моделей и
других функций, используемых как на сервере, так и на клиенте.
Meteor предоставляет переменные [`isClient` и `isServer`](#meteor_isclient), так что ваш
код может изменяться в зависимости от места использования (на сервере или клиенте).
(Файлы из директории `tests` не загружаются нигде)

Любой код, который вы не хотите отрабатывать на клиенте, например код,
содержащий пароли или аутентификационные механизмы, должен храниться
в директории `server`.

CSS файлы лучше держать в одном месте, клиент получит их все пакетом
из всех CSS в вашем рабочем дереве директорий (за исключением `server`
и `public` поддиректорий).

В режиме разработки JavaScript и CSS файлы посылаются по отдельности,
чтобы облегчить отладку приложения.

HTML файлы в приложении Meteor обрабатываются иначе, чем это принято в 
серверных фреймворках.  Meteor сканирует все HTML файлы в вашей
диреткории на предмет трех элементов: `<head>`, `<body>`, и
`<template>`.  Все заголовки и тела собираются в единый заголовок и тело
и передаются на клиента при первой загрузке приложения.

Код в секции template конвертируется в JavaScript
функции доступные в пространстве имен `Template`.  Это
действительно удобный метод доставки шаблонов клиенту.
Подробности смотри [templates](#templates).

Последнее: сервер Meteor будет раздавать любые файлы из директории
`public`, как, например, в Rails или Django из директории static.  
Это место для изображений, `favicon.ico`, `robots.txt`, и всего остального.

Лучше выстроить приложение так, чтобы порядок загрузки файлов не
влиял на его работу. К примеру, используя [Meteor.startup](#meteor_startup),
или переместив код в Smart Packages, где вы сможете управлять порядком загрузки пакетов.
Однако иногда переопределить порядок загрузки зависимостей невозможно.
JavaScript и CSS файлы в приложении загружаются сообразно своим правилам:

* Файлы в корневой директории `lib` загружаются первыми.

* Файлы совпадающие с `main.*` загружаются следующими.

* Файлы в поддиректориях загружаются снизу вверх,
  так файлы в наиболее глубоких директориях загружаются первыми
  (сразу после `lib`), а файлы в корневых директориях загружаются последними
  (за исключением `main.*`).

* Внутри директории файлы загружаются в алфавитном порядке.

Это правила. Так, например,  в директории `lib` файлы
загрузятся в алфавитном порядке и если есть файлы `main.js`,
то они загрузятся раньше файлов в поддиректориях.

{{/better_markdown}}
</template>

<template name="data">
{{#better_markdown}}

<h2 id="dataandsecurity">Информация и безопастность</h2>

Meteor дает возможность писать распределенный клиентский код настолько
просто, словно вы напрямую соединены с локальной базой данных.  Это просто,
понятно, безопасно и освобождает вас от реализации RPC, ручного кеширования
данных на клиенте для компенсации задержек, и позволяет аккуратно доставить все 
сообщения всем клиентам при изменении данных.

В Meteor клиент и сервер используют единый API базы данных. Код
приложения &mdash; такой как валидаторы и вычисляемые свойства &mdash; могут
быть использованы как на клиенте, так и на сервере.Однако код, запущенный на сервере,
имеет прямой доступ к базе данных, а код на клиенте *нет*.
Это разделение - основы модели безопастности фреймворка.

{{#note}}
По умолчанию новое приложение включает пакеты `autopublish` и `insecure`,
которые вместе имитируют эффект того, что каждый клиент имеет полный доступ
к базе данных на чтение/запись.  Это полезно в качестве мощного инструмента
прототипирования, но обычно неприемлемо для реальных приложения.
При выходе в продакшн просто удалите эти пакеты.
{{/note}}

Каждый клиент Meteor-а включает в себя кеш базы данных.  Для управления
клиентским кешем, сервер *publishes* (публикует) набор JSON документов,
а клиент в свою очередь *subscribes* (подписывается) на эти наборы.
Как только документы в наборе изменяются, сервер патчит кеш каждого клиента 
до актуального состояния.

Каждый набор документов объявлен publish функцией на сервере.
Данная функция запускается каждый раз, когда новый клиент подписывается
на набор документов. Данные в наборе документов могут быть откуда угодно,
но в основном публикуются данные из базы.

    // server: публикует все документы комнаты
    Meteor.publish("all-rooms", function () {
      return Rooms.find(); // everything
    );

    // server: публикует все сообщения для конкретной комнаты
    Meteor.publish("messages", function (roomId) {
      return Messages.find({room: roomId});
    });

    // server: публикует список вечеринок которые видит пользователь
    Meteor.publish("parties", function () {
      return Parties.find({$or: [{"public": true},
                                 {invited: this.userId},
                                 {owner: this.userId}]});
    });

Publish функция может отдавать разные результаты каждому клиенту.  
В последнем примере, залогиненный пользователь может видеть только 
те документы `Party`, которые являются публичными, т.е. которыми пользователь владеет,
или те в которые пользователь приглашен.

Однажды подписавшись, клиент использует свой собственный кэш как локальную
базу данных, это в значительной степени облегчает клиентский код.  
Операции на чтение не тратят время на отсылку и прием запросов с сервера. 
На самом деле клиенту передаются только те данные, которые претерпели
изменения. 

    // client: start a parties subscription
    Meteor.subscribe("parties");

    // client: return array of Parties this client can read
    return Parties.find().fetch(); // synchronous!

На клиенте можно отключать и включать подписки для контроля
размеров кэша и управления сетевым траффиком.  Когда подписка
отключена, все ее документы удаляются из кэша, но только если 
нет других активных подписок связанных с этим документом.

Когда на клиенте происходят *changes* (изменения) одного или более документов,
он шлет сообщение на сервер, в свою очередь сервер запрашивает изменения.
После чего осуществляет проверку на соотвествие правил безопастности,
которые объявляются как JavaScript функция.
Сервер принимает только те изменения, которые не противоречат его политике.

    // server: запретить запись клиенту в коллекцию Parties
    Parties.allow({
      insert: function (userId, party) {
        return false;
      }
    });

    // client: тут произойдет фейл
    var party = { ... };
    Parties.insert(party);

Если сервер принял изменения, то он применяет их  сначала к базе
, после этого автоматически распространяет изменения на всех клиентов,
которые подписаны на этот документ.  В противном случае обновления не происходит,
обновления не применяются к базе данных и другие клиенты соотвественно не получают
никаких обновлений, связанных с отброшенным обновлением.

Meteor использует одну уловку:  когда клиент отправляет запрос на запись серверу,
он также обновляет локальный кэш не дожидаясь ответа. 
Это означает, что экран на клиенте обновляется сразу же.
И если сервер принял обновления &mdash; что происходит в большинстве
случаев, когда клиент работает верно &mdash;, то у клиента изменения вступают 
в силу сразу же и экран обновлен без какого-либо ответа от сервера.
Но если сервер отверг обновления,  то Meteor обновляет кеш клиента 
актуальными данными из базы данных сервера.

Если сложить все вместе, то все эти техники позволяют компенсировать задержки.
Клиенты всегда имеют свежую копию необходимых им данных, и
не надо тратить время на ожидание времени отправки запроса на сервер и получения ответа,
локальная копия данных на клиенте обновляется мгновенно.

Meteor включает [Meteor Accounts](#accounts_api), систему аутентификации.
Она предоставляет безопасный парольный вход [Secure Remote Password protocol]
(http://en.wikipedia.org/wiki/Secure_Remote_Password_protocol), и
интеграцию с внешними сервисами включая Facebook, GitHub, Google, Twitter,
и Weibo. Meteor Accounts объявляет [`Meteor.users`](#meteor_users) коллекцию,
где разработчик может хранить связанную с пользователем информацию.

Meteor также включает готовые формы для основных действий, таких как вход,
регистрация, смена пароля, и сброс пароля через email. Вы можете добавить [Accounts
UI](#accountsui) в ваше приложение всего одной строкой кода. `accounts-ui` smart
package так же предоставляет визард, который проведет вас через шаги подключения
к внешним сервисам авторизации.

{{#note}}
Настоящий релиз Meteor поддерживает MongoDB, популярную документо-
ориентированную базу данных, документацию можно найти
        [MongoDB API](http://www.mongodb.org/display/DOCS/Manual).
В будущем планируется ввести поддержку других баз данных.
{{/note}}

{{/better_markdown}}
</template>

<template name="reactivity">
{{#better_markdown}}

<h2 id="reactivity">Реактивность</h2>

Meteor включает в себя концепцию [reactive
programming](http://en.wikipedia.org/wiki/Reactive_programming). Это означает,
что вы можете писать свой код в простом императивном стиле, а результат будет пересчитан
автоматически при измении данных с которыми связан ваш код.

    Meteor.autosubscribe(function () {
      Meteor.subscribe("messages", Session.get("currentRoomId"));
    });

Этот пример (взятый из чат-клиента) устанавливает
подписку на данные в переменной сессии `currentRoomId`.
Если даные в `Session.get("currentRoomId")` изменяются по каким-то причинам,
функция автоматически перезапустится, установив новую подписку и
заменяя старую.


Этот автоматический пересчет достигается за счет взаимодействия
между `Session` и `Meteor.autosubscribe`.
Методы, наподобии `Meteor.autosubscribe`, устанавливают "reactive
context" (реактивный контекст), внутри которого отслеживают зависимости данных,
и они при необходимости готовы перезапуститься с другим аргументом. Такие
функции как, например `Session`, запоминают
контекст в котором они вызывались и данные которые были запрошены, и 
готовятся к отправке сигнала о том, что произошли изменения.

Этот простой паттерн (reactive context + reactive data source) имеет
широкое применение.  Потому что программист избавлен от необходимости
отписываться/переподписываться и убеждаться, что все вызовы происходят в нужное время.  
В общем, Meteor может помочь избежать широкого круга ошибок 
связанных с распростарнением событий и приводящих к ошибкам
логики приложения.

Эти функции Meteor запускают ваш код в реактивном контексте:

* [Templates](#templates)
* [`Meteor.render`](#meteor_render) and [`Meteor.renderList`](#meteor_renderlist)
* [`Meteor.autosubscribe`](#meteor_autosubscribe)
* [`Meteor.autorun`](#meteor_autorun)

И реактивные источники данных которые могут оповещать о изменениях:

* [`Session`](#session) variables
* Database queries on [Collections](#find)
* [`Meteor.status`](#meteor_status)
* [`Meteor.user`](#meteor_user)
* [`Meteor.userId`](#meteor_userid)
* [`Meteor.loggingIn`](#meteor_loggingin)

Meteor's
[implementation](https://github.com/meteor/meteor/blob/master/packages/deps/deps.js)
(реализация) коротка и изящна, составляет около 50 строк кода.  Вы можете перхватить
ее самостоятельно для добавления нового реактивного контекста или источника данных,
используя [`Meteor.deps`](#meteor_deps) модуль.

{{/better_markdown}}
</template>

<template name="livehtml">
{{#better_markdown}}

<h2 id="livehtml">:Живой HTML</h2>

HTML шаблоны- это одна из центральных тем веб-приложения. С технологией
живого обновления страницы вы можете рендерить html _reactively_, это 
означает,что данные обновляются автоматически при обнаружении изменений в них.

Эта технология работает с любым HTML шаблонизатором, или даже
с HTML, который вы нагенерили вручную из JavaScript. Нпример:

    var fragment = Meteor.render(
      function () {
        var name = Session.get("name") || "Anonymous";
        return "<div>Hello, " + name + "</div>";
      });
    document.body.appendChild(fragment);

    Session.set("name", "Bob"); // страница обновится автоматически!

[`Meteor.render`](#meteor_render) принимает рендер функцию, которая 
возвращает HTML в виде строки. Она возвращет автообновляющийся фрагмент
`DocumentFragment`. Когда данные используемые рендер функцией обновляются,
то она автоматически перезапускается. [`Meteor.render`](#meteor_render) использует
[reactive contexts](#reactivity) для поиска данных используемых в рендер
функции.

Большуя часть времени вы не будете вызывать эти функции напрямую
&mdash; вы просто используете свой любый шаблонизатор, такой как
Handlebars или Jade. `render` и `renderList` функции интерсны для
разработчиков, которые хотят интегрировать свои собственные шаблонизаторы.

Обычно Метеор производит обновления данных когда ваш код не исполняется. 
Таким образом,  вы можете быть уверены в том, что DOM
не изменится незаметно для вас(имеется ввиду, что сам не добавит элементов в дерево).
Иногда необходимо обратное.
К примеру, если вы только что вставили запись в базу, 
вы захотите запустить принудительное обновление DOM , тогда для
поиска и создания новых элементов вы можете использовать библиотеки на
подобии jQuery. Так вы можете вызвать [`Meteor.flush`](#meteor_flush)
дял того чтобы обновить DOM немедлено.

Когда авто-обновляющиеся DOM исчезают с экрана, они автоматически удаляются &mdash; 
их колбеки отключаются, любые посланые в базу данных запросы останавливаются 
и они перестают обновляться. Поэтому вам никогда не придется беспокоится о
[zombie templates](http://lostechies.com/derickbailey/2011/09/15/zombies-run-managing-page-transitions-in-backbone-apps/)
которые порождает вручную написанная логика обновлений. Для защиты своих элементов от уничтожения,
просто убедитесь, что они на экране, до того как ваш код вернется в event loop,
или до любых вызовов [`Meteor.flush`](#meteor_flush).

Другой интересной проблемой в веб-приложении является сохрание состояния
элемента. Представим, что пользователь пишет текст в  `<input>`
элемент, и когда участок страницы, который включает этот элемент
перерисовывается, пользователь, например, может сместить фокус в приложении
и частиточно введеный текст пропадет в перерисованном `<input>`.

Еще одна проблема которую Метеор решает для вас. Вы можете определить элементы
для сохранения когда шаблоны пересоздаются с
[`preserve`](#template_preserve) дерективой в шаблоне.

{{/better_markdown}}
</template>

<template name="templates">
{{#better_markdown}}

<h2 id="templates">Шаблоны</h2>

Метеор упрощает использование вашего любимого шаблонного языка,
таких как Handlebars или Jade, с технологией обновления шаблонов налету
Просто пишите свои шаблоны как обычно, а Метеор
позаботится о их обновлении.

Для использования этой возможности создайте файл с расширением `.html`
В файле создайте `<template>` тег и задайте ему атрибут `name` . 
Поместите содержимое шаблона внутри тега. Метеор
скомпелирует шаблон, передаст его на клиента и сделает
его досутпным в виде функции в глобальном объекте `Template` .

{{#note}}
Сегодня в Метеоре доступен только один шаблонизатор Handlebars.
Дайте нам знать какие шаблонизаторы вы бы хотели использовать с 
Метеором. Так же смотрите [Handlebars
документацию](http://www.handlebarsjs.com/) and [Meteor Handlebars
расширения](https://github.com/meteor/meteor/wiki/Handlebars).
{{/note}}

Шаблон с именем `hello` рендерится функцией `Template.hello`,
передавая любые данные в шаблон:

    <!-- in myapp.html -->
    <template name="hello">
      <div class="greeting">Hello there, {{dstache}}first}} {{dstache}}last}}!</div>
    </{{! }}template>

    // in the JavaScript console
    > Template.hello({first: "Alyssa", last: "Hacker"});
     => "<div class="greeting">Hello there, Alyssa Hacker!</div>"

Это вернет строку. Для использования шаблона с [`Live
HTML`](#livehtml) и получения DOM элементов которые обновляются
автоматически, исполуйте [`Meteor.render`](#meteor_render):

    Meteor.render(function () {
      return Template.hello({first: "Alyssa", last: "Hacker"});
    })
      => автоматическое обновление DOM элементов

Простейший путь передать данные в шаблон- это определние функции хелпера на JavaScript.
Просто добавьте функцию хелпер прямо в 
`Template.[template name]` объект. Как, например, в этом шаблоне:

    <template name="players">
      {{dstache}}#each topScorers}}
        <div>{{dstache}}name}}</div>
      {{dstache}}/each}}
    </{{! }}template>

вместо передачи `topScorers` как аргумента,
мы можем определить функцию в `Template.players`:

    Template.players.topScorers = function () {
      return Users.find({score: {$gt: 100}}, {sort: {score: -1}});
    };

В таком случае, данные приходят из запроса в базу. Когда
курсор базы дойдет до `#each`, он соединит и будет эффективно
добавлять или перемещать DOM узлы, как новые результаты введенного
запроса.

Хелперы могут принимать аргументы, и они принимают актуальные данные шаблона
в `this`:

    // in a JavaScript file
    Template.players.leagueIs = function (league) {
      return this.league === league;
    };

    <!-- in a HTML file -->
    <template name="players">
      {{dstache}}#each topScorers}}
        {{dstache}}#if leagueIs "junior"}}
          <div>Junior: {{dstache}}name}}</div>
        {{dstache}}/if}}
        {{dstache}}#if leagueIs "senior"}}
          <div>Senior: {{dstache}}name}}</div>
        {{dstache}}/if}}
      {{dstache}}/each}}
    </{{! }}template>

{{#note}}
Handlebars заметка: `{{dstache}}#if leagueIs "junior"}}`
это расширение Метеора, которое допускает вкладывать блоки
хелперов  друг в друга. (Оба `if` и `leagueIs`
хелперы, обычный Handlebars не будет вызывать
`leagueIs` здесь.)
{{/note}}

Хелперы также можно использовать для передачи констант.

    // Works fine with {{dstache}}#each sections}}
    Template.report.sections = ["Situation", "Complication", "Resolution"];

Наконец, вы можете использовать `events` декларации в шаблоных функциях для установки
таблицы обработчиков событий. Формат задокументирован в [Event
Maps](#eventmaps). `this` аргумент для обработчика события будет
контекстом элемента запустившего событие.

    <!-- myapp.html -->
    <template name="scores">
      {{dstache}}#each player}}
        {{dstache}}> playerScore}}
      {{dstache}}/each}}
    </{{! }}template>

    <template name="playerScore">
      <div>{{dstache}}name}}: {{dstache}}score}}
        <span class="givePoints">Give points</span>
      </div>
    </{{! }}template>

    <!-- myapp.js -->
    Template.playerScore.events({
      'click .givePoints': function () {
        Users.update({_id: this._id}, {$inc: {score: 2}});
      }
    });

Сложим все вместе, пример как вы можете добавить
произвольные данные в ваши шаблоны и получить автообновления
при любых изменениях данных. Смотрите [Live HTML](#livehtml).

    <!-- in myapp.html -->
    <template name="forecast">
      <div>It'll be {{dstache}}prediction}} tonight</div>
    </{{! }}template>

    <!-- in myapp.js -->
    // JavaScript: reactive helper function
    Template.forecast.prediction = function () {
      return Session.get("weather");
    };

    <!-- in the console -->
    > Session.set("weather", "cloudy");
    > document.body.appendChild(Meteor.render(Template.forecast));
    In DOM:  <div>It'll be cloudy tonight</div>

    > Session.set("weather", "cool and dry");
    In DOM:  <div>It'll be cool and dry tonight</div>

{{/better_markdown}}
</template>

<template name="packages_concept">
{{#better_markdown}}

  <h2 id="smartpackages">Умные пакеты</h2>

У Метеора есть необыкновенно мощная система пакетов. Весь
функционал, о котором вы читаете, реализован на пакетах Метеор.

Пакеты- это не что иное, как JavaScript программы. Они могут вставлять код 
прямо в клиентскую или серверную часть или захватывать новые функции в наборы.
Так они могут расширять окружение Метеора.
Некоторые примеры пакетов:

* [coffeescript](#coffeescript) пакет позволяет
  автоматически компелировать любые `.coffee` файлы в вашем
  проекте.  Добавив один раз вы можете писать свой проект на CoffeeScript
  вместо JavaScript.

* [jQuery](#jquery) и [Backbone](#backbone) примеры использования
  клиентских JavaScript библиотек. Вы можете получить тот же результат
  простым копированием JavaScript файлов в ваш проект, но
  быстрее добавить пакет.

* [underscore](#underscore) пакет расширяет клиент-серверное
  окружение.  Многие ключевые возможности Метеора
  включая Minimongo, Session объект, и реактивные Handlebars
  шаблоны, реализованы как внутренние пакеты автоматически
  подключаемые в каждом новом приложении.

Вы можете посмотреть список доступных пакетов
с [`meteor list`](#meteorlist), добавить пакеты в проект
с [`meteor add`](#meteoradd), и удалить их
с [`meteor remove`](#meteorremove).

Смотри [Package List](#packages) раздел для описания
существующих пакетов.

{{#warning}}
API пакетов часто изменяется и не документируется, пока вы
не можете создавать свои пакеты. Но скоро будет.
{{/warning}}

{{/better_markdown}}
</template>





<template name="deploying">
{{#better_markdown}}

<h2 id="deploying">Развертывание</h2>

Метеор это сервер приложений.  Мы включили все, что необходимо
для развертывания вашего приложения в интернете: вы просто предоставляете JavaScript,
HTML, и CSS.

<h3 class="nosection">Запуск на инфраструктуре Метеор</h3>

Простейший способ развернуть ваше приложение- это использовать `meteor
deploy`. Мы прелагем это, потому что нашей целью является простое
воплощение вашей идеи в приложение, например за выходные, и быстрое размещение
в интернете на всеобщее обозрение,а также для того,чтобы ничего не мешало вашей креативности

    $ meteor deploy myapp.meteor.com

Ваше приложение теперь доступно на myapp.meteor.com.  Если
это первое развертывание на данном домене, Метеор создает
свежую пустую базу для вашего приложения.  Если вы хотите развернуть
обновления, Метеор сохранит данные в базе и только обновит код.

Вы также можете развернуть на своем собственном домене.
Просто установите доменное имя, которое вы хотите использовать как
CNAME для `origin.meteor.com`, и после этого разворачивайтесь на это имя.

    $ meteor deploy www.myapp.com

Мы предоставляем это как бесплатный сервис и так вы можете попробовать Метеор. 
Это так же полезно для быстрого развертывания внутренних бет, демок и тому подобного.

<h3 class="nosection">Запуск на своей инфраструктуре</h3>

Вы так же можете запустить ваше приложение на собственной архитектуре, или на 
любом другом хостинге типо Heroku.

Для начала, запустите

    $ meteor bundle myapp.tgz

Эта команда сгенерирует полное Node.js приложение в виде
tar архива.  Для запуска приложения вам необходимы
Node.js 0.8 и MongoDB сервер.  Тогда вы можете запустить приложение
отдельным узлом, указав HTTP порт, который будет слушать приложение
и сервер MongoDB.  Если у вас до сих пор нет Монго сервера,
мы можем порекомендовать наших друзей [MongoHQ](http://mongohq.com).

    $ PORT=3000 MONGO_URL=mongodb://localhost:27017/myapp node bundle/main.js

Другие пакеты могут требовать другие переменные окружения (к примеру `email`
пакет требует переменную окружения `MAIL_URL`).

{{#warning}}
Сейчас сборка может быть запущена только на такой же платформе на какой она
была создана.  Для запуска на другой платформе вам необходимо пересобрать
сборку включая пакеты.  Для этого убедитесь, что у вас установлен `npm` 
и запустите:

    $ cd bundle/server/node_modules
    $ rm -r fibers
    $ npm install fibers@0.6.9
{{/warning}}

{{/better_markdown}}
</template>
